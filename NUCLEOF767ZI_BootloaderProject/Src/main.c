/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <string.h>
#include <stdbool.h>
#include "stm32f7xx.h"
#include "comms_device.h"
#include "BootProtocolDefs.h"
#include "GPIO_Dependency_Injection.h"
#include "USART_Dependency_Injection.h"
#include "gpio_integration_test.h"
#include "usart_integration_test.h"
#include "boot_loader_protocol_suite.h"

#define FLASH_APP_REGION_START	0x08008000U

static void timer_setup (void);
static bool check_for_user_bootloader_mode (void);
static void jump_to_application (void);
static void boot_loader_workflow (void);
static void bootloader_setup (comms_device_t * commsDevice, usart_device usartDevice);

static comms_device_t commsDevice;

#define BL_RX_LEN  200
static uint8_t bl_rx_buffer[BL_RX_LEN];
static uint16_t preamble = 0x3F3F;

static void (*boot_loader_operations[9]) (uint8_t * command_packet, comms_device_t commsDevice, uint32_t length) = {0, bl_get_version,
		bl_get_help, bl_get_chip_id, bl_get_rdp_status, bl_go_to_app_address, bl_flash_erase, bl_mem_write, bl_enable_read_write_protect};


int main(void)
{
	setup_usart_alternate();
	//setup_usart_default();
	setup_gpio_integration_test_gpio_portB();
	setup_gpio_integration_test_gpio_portC();
	bool runBootLoader = false;
	usart_device usartDevice = getUSARTDeviceInstance (USART_INSTANCE_5);
	bootloader_setup (&commsDevice, usartDevice);
	/*
	 * check for user button press on reset. If pressed it will enter the bootloader flow.
	 * If not pressed it will jump to the latest flashed application.
	 */
	timer_setup();
	turn_on_BLUE_LED_PORTB();
	runBootLoader = check_for_user_bootloader_mode();
	turn_off_BLUE_LED_PORTB();
	if (runBootLoader == true) {
		turn_on_GREEN_LED_PORTB();
		//run the user boot loader work flow
		boot_loader_workflow();
		//jump to and run the latest flashed application
		jump_to_application();
	}
	if (runBootLoader == false) {
		//jump to and run the latest flashed application
		jump_to_application();
	}

	while (1) {
	}
}

static void boot_loader_workflow (void) {
	uint8_t recv_len = 0;
	uint16_t preamble_rcvd = 0;
	uint8_t ackPreamble = ACK_PREAMBLE;
	memset(bl_rx_buffer, 0, BL_RX_LEN);
	while (1) {
		while (preamble_rcvd != preamble) {
			Comms_Device_RecvPacket(commsDevice, &preamble_rcvd, sizeof(preamble_rcvd));
		}
		//acknowledge the preamble
		Comms_Device_SendPacket(commsDevice, &ackPreamble, sizeof(ackPreamble));
		//read the length of bytes to follow after the first one from the host
		Comms_Device_RecvPacket(commsDevice, bl_rx_buffer, 1);
		recv_len = bl_rx_buffer[0];
		//read the rest of the command packet from the host
		Comms_Device_RecvPacket(commsDevice, bl_rx_buffer+1, recv_len);
		//process the received packet
		boot_loader_operations[bl_rx_buffer[1]] (bl_rx_buffer, commsDevice, recv_len+1);
		//reset preamble
		preamble_rcvd = 0;
		memset(bl_rx_buffer, 0, BL_RX_LEN);
	}
}

static bool check_for_user_bootloader_mode (void) {
	bool userBootLoaderFlag = false;
	uint32_t userButtonValue = 0;
	gpio_device gpioPortC = getGPIODeviceInstance(PORTC);
	for (int index = 0; index < 30; index++) {
		while (!(TIM2->SR &TIM_SR_UIF)) {}
		TIM2->SR = ~TIM_SR_UIF; //reset UIF
		userButtonValue = readGPIOInputDataRegister(gpioPortC);
		if ((userButtonValue & (1 << 13)) == (1 << 13)) {
			userBootLoaderFlag = true;
			break;
		}
	}
	TIM2->SR = ~TIM_SR_UIF; //reset UIF
	return userBootLoaderFlag;
}

static void jump_to_application (void) {
	//MSP value stored at 0x08008000 in flash
	run_application (FLASH_APP_REGION_START);
}

static void timer_setup (void) {
	//enable TIM2 timer access
	RCC->APB1ENR |= (1 << 0);
	//set the TIM2 prescaler register to 255
	TIM2->PSC = 16000-1; //16,000,000 Hz / (15,999+1) = 1,000Hz
	//set ARR register to the target count value
	TIM2->ARR = 1000-1; // 1,000Hz/1,000 = 1Hz
	//enable the counter CEN bit set
	TIM2->CR1 |= (1 << 0);
}

static void bootloader_setup (comms_device_t * commsDevice, usart_device usartDevice) {
	*commsDevice = Comms_Init(INSTANCE_0,usartDevice);
	Comms_Device_Enable(*commsDevice);
}
